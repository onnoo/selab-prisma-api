module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Account {
  id: ID!
  user_id: String!
  user_pwd: String!
  permission: Permission!
  createdAt: DateTime!
}

type AccountConnection {
  pageInfo: PageInfo!
  edges: [AccountEdge]!
  aggregate: AggregateAccount!
}

input AccountCreateInput {
  id: ID
  user_id: String!
  user_pwd: String!
  permission: Permission!
}

input AccountCreateOneInput {
  create: AccountCreateInput
  connect: AccountWhereUniqueInput
}

type AccountEdge {
  node: Account!
  cursor: String!
}

enum AccountOrderByInput {
  id_ASC
  id_DESC
  user_id_ASC
  user_id_DESC
  user_pwd_ASC
  user_pwd_DESC
  permission_ASC
  permission_DESC
  createdAt_ASC
  createdAt_DESC
}

type AccountPreviousValues {
  id: ID!
  user_id: String!
  user_pwd: String!
  permission: Permission!
  createdAt: DateTime!
}

type AccountSubscriptionPayload {
  mutation: MutationType!
  node: Account
  updatedFields: [String!]
  previousValues: AccountPreviousValues
}

input AccountSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AccountWhereInput
  AND: [AccountSubscriptionWhereInput!]
  OR: [AccountSubscriptionWhereInput!]
  NOT: [AccountSubscriptionWhereInput!]
}

input AccountUpdateDataInput {
  user_id: String
  user_pwd: String
  permission: Permission
}

input AccountUpdateInput {
  user_id: String
  user_pwd: String
  permission: Permission
}

input AccountUpdateManyMutationInput {
  user_id: String
  user_pwd: String
  permission: Permission
}

input AccountUpdateOneRequiredInput {
  create: AccountCreateInput
  update: AccountUpdateDataInput
  upsert: AccountUpsertNestedInput
  connect: AccountWhereUniqueInput
}

input AccountUpsertNestedInput {
  update: AccountUpdateDataInput!
  create: AccountCreateInput!
}

input AccountWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user_id: String
  user_id_not: String
  user_id_in: [String!]
  user_id_not_in: [String!]
  user_id_lt: String
  user_id_lte: String
  user_id_gt: String
  user_id_gte: String
  user_id_contains: String
  user_id_not_contains: String
  user_id_starts_with: String
  user_id_not_starts_with: String
  user_id_ends_with: String
  user_id_not_ends_with: String
  user_pwd: String
  user_pwd_not: String
  user_pwd_in: [String!]
  user_pwd_not_in: [String!]
  user_pwd_lt: String
  user_pwd_lte: String
  user_pwd_gt: String
  user_pwd_gte: String
  user_pwd_contains: String
  user_pwd_not_contains: String
  user_pwd_starts_with: String
  user_pwd_not_starts_with: String
  user_pwd_ends_with: String
  user_pwd_not_ends_with: String
  permission: Permission
  permission_not: Permission
  permission_in: [Permission!]
  permission_not_in: [Permission!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
}

input AccountWhereUniqueInput {
  id: ID
  user_id: String
}

type AggregateAccount {
  count: Int!
}

type AggregateAnswer {
  count: Int!
}

type AggregateCourse {
  count: Int!
}

type AggregateQuiz {
  count: Int!
}

type AggregateQuizContents {
  count: Int!
}

type AggregateSemester {
  count: Int!
}

type Answer {
  id: ID!
  quiz: Quiz!
  user: Account!
  content: String!
  createdAt: DateTime!
}

type AnswerConnection {
  pageInfo: PageInfo!
  edges: [AnswerEdge]!
  aggregate: AggregateAnswer!
}

input AnswerCreateInput {
  id: ID
  quiz: QuizCreateOneWithoutAnswersInput!
  user: AccountCreateOneInput!
  content: String!
}

input AnswerCreateManyWithoutQuizInput {
  create: [AnswerCreateWithoutQuizInput!]
  connect: [AnswerWhereUniqueInput!]
}

input AnswerCreateWithoutQuizInput {
  id: ID
  user: AccountCreateOneInput!
  content: String!
}

type AnswerEdge {
  node: Answer!
  cursor: String!
}

enum AnswerOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
}

type AnswerPreviousValues {
  id: ID!
  content: String!
  createdAt: DateTime!
}

input AnswerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [AnswerScalarWhereInput!]
  OR: [AnswerScalarWhereInput!]
  NOT: [AnswerScalarWhereInput!]
}

type AnswerSubscriptionPayload {
  mutation: MutationType!
  node: Answer
  updatedFields: [String!]
  previousValues: AnswerPreviousValues
}

input AnswerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AnswerWhereInput
  AND: [AnswerSubscriptionWhereInput!]
  OR: [AnswerSubscriptionWhereInput!]
  NOT: [AnswerSubscriptionWhereInput!]
}

input AnswerUpdateInput {
  quiz: QuizUpdateOneRequiredWithoutAnswersInput
  user: AccountUpdateOneRequiredInput
  content: String
}

input AnswerUpdateManyDataInput {
  content: String
}

input AnswerUpdateManyMutationInput {
  content: String
}

input AnswerUpdateManyWithoutQuizInput {
  create: [AnswerCreateWithoutQuizInput!]
  delete: [AnswerWhereUniqueInput!]
  connect: [AnswerWhereUniqueInput!]
  set: [AnswerWhereUniqueInput!]
  disconnect: [AnswerWhereUniqueInput!]
  update: [AnswerUpdateWithWhereUniqueWithoutQuizInput!]
  upsert: [AnswerUpsertWithWhereUniqueWithoutQuizInput!]
  deleteMany: [AnswerScalarWhereInput!]
  updateMany: [AnswerUpdateManyWithWhereNestedInput!]
}

input AnswerUpdateManyWithWhereNestedInput {
  where: AnswerScalarWhereInput!
  data: AnswerUpdateManyDataInput!
}

input AnswerUpdateWithoutQuizDataInput {
  user: AccountUpdateOneRequiredInput
  content: String
}

input AnswerUpdateWithWhereUniqueWithoutQuizInput {
  where: AnswerWhereUniqueInput!
  data: AnswerUpdateWithoutQuizDataInput!
}

input AnswerUpsertWithWhereUniqueWithoutQuizInput {
  where: AnswerWhereUniqueInput!
  update: AnswerUpdateWithoutQuizDataInput!
  create: AnswerCreateWithoutQuizInput!
}

input AnswerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quiz: QuizWhereInput
  user: AccountWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [AnswerWhereInput!]
  OR: [AnswerWhereInput!]
  NOT: [AnswerWhereInput!]
}

input AnswerWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Course {
  id: ID!
  code: String!
  name: String!
  semesters(where: SemesterWhereInput, orderBy: SemesterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Semester!]
  degree: String!
}

type CourseConnection {
  pageInfo: PageInfo!
  edges: [CourseEdge]!
  aggregate: AggregateCourse!
}

input CourseCreateInput {
  id: ID
  code: String!
  name: String!
  semesters: SemesterCreateManyWithoutCoursesInput
  degree: String!
}

input CourseCreateManyWithoutSemestersInput {
  create: [CourseCreateWithoutSemestersInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateOneInput {
  create: CourseCreateInput
  connect: CourseWhereUniqueInput
}

input CourseCreateWithoutSemestersInput {
  id: ID
  code: String!
  name: String!
  degree: String!
}

type CourseEdge {
  node: Course!
  cursor: String!
}

enum CourseOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  name_ASC
  name_DESC
  degree_ASC
  degree_DESC
}

type CoursePreviousValues {
  id: ID!
  code: String!
  name: String!
  degree: String!
}

input CourseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  degree: String
  degree_not: String
  degree_in: [String!]
  degree_not_in: [String!]
  degree_lt: String
  degree_lte: String
  degree_gt: String
  degree_gte: String
  degree_contains: String
  degree_not_contains: String
  degree_starts_with: String
  degree_not_starts_with: String
  degree_ends_with: String
  degree_not_ends_with: String
  AND: [CourseScalarWhereInput!]
  OR: [CourseScalarWhereInput!]
  NOT: [CourseScalarWhereInput!]
}

type CourseSubscriptionPayload {
  mutation: MutationType!
  node: Course
  updatedFields: [String!]
  previousValues: CoursePreviousValues
}

input CourseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseWhereInput
  AND: [CourseSubscriptionWhereInput!]
  OR: [CourseSubscriptionWhereInput!]
  NOT: [CourseSubscriptionWhereInput!]
}

input CourseUpdateDataInput {
  code: String
  name: String
  semesters: SemesterUpdateManyWithoutCoursesInput
  degree: String
}

input CourseUpdateInput {
  code: String
  name: String
  semesters: SemesterUpdateManyWithoutCoursesInput
  degree: String
}

input CourseUpdateManyDataInput {
  code: String
  name: String
  degree: String
}

input CourseUpdateManyMutationInput {
  code: String
  name: String
  degree: String
}

input CourseUpdateManyWithoutSemestersInput {
  create: [CourseCreateWithoutSemestersInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutSemestersInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutSemestersInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithWhereNestedInput {
  where: CourseScalarWhereInput!
  data: CourseUpdateManyDataInput!
}

input CourseUpdateOneRequiredInput {
  create: CourseCreateInput
  update: CourseUpdateDataInput
  upsert: CourseUpsertNestedInput
  connect: CourseWhereUniqueInput
}

input CourseUpdateWithoutSemestersDataInput {
  code: String
  name: String
  degree: String
}

input CourseUpdateWithWhereUniqueWithoutSemestersInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutSemestersDataInput!
}

input CourseUpsertNestedInput {
  update: CourseUpdateDataInput!
  create: CourseCreateInput!
}

input CourseUpsertWithWhereUniqueWithoutSemestersInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutSemestersDataInput!
  create: CourseCreateWithoutSemestersInput!
}

input CourseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  semesters_every: SemesterWhereInput
  semesters_some: SemesterWhereInput
  semesters_none: SemesterWhereInput
  degree: String
  degree_not: String
  degree_in: [String!]
  degree_not_in: [String!]
  degree_lt: String
  degree_lte: String
  degree_gt: String
  degree_gte: String
  degree_contains: String
  degree_not_contains: String
  degree_starts_with: String
  degree_not_starts_with: String
  degree_ends_with: String
  degree_not_ends_with: String
  AND: [CourseWhereInput!]
  OR: [CourseWhereInput!]
  NOT: [CourseWhereInput!]
}

input CourseWhereUniqueInput {
  id: ID
  code: String
}

scalar DateTime

scalar Long

type Mutation {
  createAccount(data: AccountCreateInput!): Account!
  updateAccount(data: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account
  updateManyAccounts(data: AccountUpdateManyMutationInput!, where: AccountWhereInput): BatchPayload!
  upsertAccount(where: AccountWhereUniqueInput!, create: AccountCreateInput!, update: AccountUpdateInput!): Account!
  deleteAccount(where: AccountWhereUniqueInput!): Account
  deleteManyAccounts(where: AccountWhereInput): BatchPayload!
  createAnswer(data: AnswerCreateInput!): Answer!
  updateAnswer(data: AnswerUpdateInput!, where: AnswerWhereUniqueInput!): Answer
  updateManyAnswers(data: AnswerUpdateManyMutationInput!, where: AnswerWhereInput): BatchPayload!
  upsertAnswer(where: AnswerWhereUniqueInput!, create: AnswerCreateInput!, update: AnswerUpdateInput!): Answer!
  deleteAnswer(where: AnswerWhereUniqueInput!): Answer
  deleteManyAnswers(where: AnswerWhereInput): BatchPayload!
  createCourse(data: CourseCreateInput!): Course!
  updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
  updateManyCourses(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): BatchPayload!
  upsertCourse(where: CourseWhereUniqueInput!, create: CourseCreateInput!, update: CourseUpdateInput!): Course!
  deleteCourse(where: CourseWhereUniqueInput!): Course
  deleteManyCourses(where: CourseWhereInput): BatchPayload!
  createQuiz(data: QuizCreateInput!): Quiz!
  updateQuiz(data: QuizUpdateInput!, where: QuizWhereUniqueInput!): Quiz
  updateManyQuizzes(data: QuizUpdateManyMutationInput!, where: QuizWhereInput): BatchPayload!
  upsertQuiz(where: QuizWhereUniqueInput!, create: QuizCreateInput!, update: QuizUpdateInput!): Quiz!
  deleteQuiz(where: QuizWhereUniqueInput!): Quiz
  deleteManyQuizzes(where: QuizWhereInput): BatchPayload!
  createQuizContents(data: QuizContentsCreateInput!): QuizContents!
  updateQuizContents(data: QuizContentsUpdateInput!, where: QuizContentsWhereUniqueInput!): QuizContents
  updateManyQuizContentses(data: QuizContentsUpdateManyMutationInput!, where: QuizContentsWhereInput): BatchPayload!
  upsertQuizContents(where: QuizContentsWhereUniqueInput!, create: QuizContentsCreateInput!, update: QuizContentsUpdateInput!): QuizContents!
  deleteQuizContents(where: QuizContentsWhereUniqueInput!): QuizContents
  deleteManyQuizContentses(where: QuizContentsWhereInput): BatchPayload!
  createSemester(data: SemesterCreateInput!): Semester!
  updateSemester(data: SemesterUpdateInput!, where: SemesterWhereUniqueInput!): Semester
  updateManySemesters(data: SemesterUpdateManyMutationInput!, where: SemesterWhereInput): BatchPayload!
  upsertSemester(where: SemesterWhereUniqueInput!, create: SemesterCreateInput!, update: SemesterUpdateInput!): Semester!
  deleteSemester(where: SemesterWhereUniqueInput!): Semester
  deleteManySemesters(where: SemesterWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum Permission {
  ADMIN
  TA
  STUDENT
}

type Query {
  account(where: AccountWhereUniqueInput!): Account
  accounts(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Account]!
  accountsConnection(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AccountConnection!
  answer(where: AnswerWhereUniqueInput!): Answer
  answers(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Answer]!
  answersConnection(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AnswerConnection!
  course(where: CourseWhereUniqueInput!): Course
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course]!
  coursesConnection(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseConnection!
  quiz(where: QuizWhereUniqueInput!): Quiz
  quizzes(where: QuizWhereInput, orderBy: QuizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quiz]!
  quizzesConnection(where: QuizWhereInput, orderBy: QuizOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuizConnection!
  quizContents(where: QuizContentsWhereUniqueInput!): QuizContents
  quizContentses(where: QuizContentsWhereInput, orderBy: QuizContentsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [QuizContents]!
  quizContentsesConnection(where: QuizContentsWhereInput, orderBy: QuizContentsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuizContentsConnection!
  semester(where: SemesterWhereUniqueInput!): Semester
  semesters(where: SemesterWhereInput, orderBy: SemesterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Semester]!
  semestersConnection(where: SemesterWhereInput, orderBy: SemesterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SemesterConnection!
  node(id: ID!): Node
}

type Quiz {
  id: ID!
  course: Course!
  semester: Semester!
  title: String!
  description: String!
  content: QuizContents!
  answers(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Answer!]
  createdAt: DateTime!
  createdBy: Account!
  deadline: DateTime
}

type QuizConnection {
  pageInfo: PageInfo!
  edges: [QuizEdge]!
  aggregate: AggregateQuiz!
}

type QuizContents {
  id: ID!
  type: QuizType!
  options: [String!]!
}

type QuizContentsConnection {
  pageInfo: PageInfo!
  edges: [QuizContentsEdge]!
  aggregate: AggregateQuizContents!
}

input QuizContentsCreateInput {
  id: ID
  type: QuizType!
  options: QuizContentsCreateoptionsInput
}

input QuizContentsCreateOneInput {
  create: QuizContentsCreateInput
  connect: QuizContentsWhereUniqueInput
}

input QuizContentsCreateoptionsInput {
  set: [String!]
}

type QuizContentsEdge {
  node: QuizContents!
  cursor: String!
}

enum QuizContentsOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
}

type QuizContentsPreviousValues {
  id: ID!
  type: QuizType!
  options: [String!]!
}

type QuizContentsSubscriptionPayload {
  mutation: MutationType!
  node: QuizContents
  updatedFields: [String!]
  previousValues: QuizContentsPreviousValues
}

input QuizContentsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuizContentsWhereInput
  AND: [QuizContentsSubscriptionWhereInput!]
  OR: [QuizContentsSubscriptionWhereInput!]
  NOT: [QuizContentsSubscriptionWhereInput!]
}

input QuizContentsUpdateDataInput {
  type: QuizType
  options: QuizContentsUpdateoptionsInput
}

input QuizContentsUpdateInput {
  type: QuizType
  options: QuizContentsUpdateoptionsInput
}

input QuizContentsUpdateManyMutationInput {
  type: QuizType
  options: QuizContentsUpdateoptionsInput
}

input QuizContentsUpdateOneRequiredInput {
  create: QuizContentsCreateInput
  update: QuizContentsUpdateDataInput
  upsert: QuizContentsUpsertNestedInput
  connect: QuizContentsWhereUniqueInput
}

input QuizContentsUpdateoptionsInput {
  set: [String!]
}

input QuizContentsUpsertNestedInput {
  update: QuizContentsUpdateDataInput!
  create: QuizContentsCreateInput!
}

input QuizContentsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: QuizType
  type_not: QuizType
  type_in: [QuizType!]
  type_not_in: [QuizType!]
  AND: [QuizContentsWhereInput!]
  OR: [QuizContentsWhereInput!]
  NOT: [QuizContentsWhereInput!]
}

input QuizContentsWhereUniqueInput {
  id: ID
}

input QuizCreateInput {
  id: ID
  course: CourseCreateOneInput!
  semester: SemesterCreateOneInput!
  title: String!
  description: String!
  content: QuizContentsCreateOneInput!
  answers: AnswerCreateManyWithoutQuizInput
  createdBy: AccountCreateOneInput!
  deadline: DateTime
}

input QuizCreateOneWithoutAnswersInput {
  create: QuizCreateWithoutAnswersInput
  connect: QuizWhereUniqueInput
}

input QuizCreateWithoutAnswersInput {
  id: ID
  course: CourseCreateOneInput!
  semester: SemesterCreateOneInput!
  title: String!
  description: String!
  content: QuizContentsCreateOneInput!
  createdBy: AccountCreateOneInput!
  deadline: DateTime
}

type QuizEdge {
  node: Quiz!
  cursor: String!
}

enum QuizOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  deadline_ASC
  deadline_DESC
}

type QuizPreviousValues {
  id: ID!
  title: String!
  description: String!
  createdAt: DateTime!
  deadline: DateTime
}

type QuizSubscriptionPayload {
  mutation: MutationType!
  node: Quiz
  updatedFields: [String!]
  previousValues: QuizPreviousValues
}

input QuizSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuizWhereInput
  AND: [QuizSubscriptionWhereInput!]
  OR: [QuizSubscriptionWhereInput!]
  NOT: [QuizSubscriptionWhereInput!]
}

enum QuizType {
  CHOICE
  ESSAY
}

input QuizUpdateInput {
  course: CourseUpdateOneRequiredInput
  semester: SemesterUpdateOneRequiredInput
  title: String
  description: String
  content: QuizContentsUpdateOneRequiredInput
  answers: AnswerUpdateManyWithoutQuizInput
  createdBy: AccountUpdateOneRequiredInput
  deadline: DateTime
}

input QuizUpdateManyMutationInput {
  title: String
  description: String
  deadline: DateTime
}

input QuizUpdateOneRequiredWithoutAnswersInput {
  create: QuizCreateWithoutAnswersInput
  update: QuizUpdateWithoutAnswersDataInput
  upsert: QuizUpsertWithoutAnswersInput
  connect: QuizWhereUniqueInput
}

input QuizUpdateWithoutAnswersDataInput {
  course: CourseUpdateOneRequiredInput
  semester: SemesterUpdateOneRequiredInput
  title: String
  description: String
  content: QuizContentsUpdateOneRequiredInput
  createdBy: AccountUpdateOneRequiredInput
  deadline: DateTime
}

input QuizUpsertWithoutAnswersInput {
  update: QuizUpdateWithoutAnswersDataInput!
  create: QuizCreateWithoutAnswersInput!
}

input QuizWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  course: CourseWhereInput
  semester: SemesterWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  content: QuizContentsWhereInput
  answers_every: AnswerWhereInput
  answers_some: AnswerWhereInput
  answers_none: AnswerWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdBy: AccountWhereInput
  deadline: DateTime
  deadline_not: DateTime
  deadline_in: [DateTime!]
  deadline_not_in: [DateTime!]
  deadline_lt: DateTime
  deadline_lte: DateTime
  deadline_gt: DateTime
  deadline_gte: DateTime
  AND: [QuizWhereInput!]
  OR: [QuizWhereInput!]
  NOT: [QuizWhereInput!]
}

input QuizWhereUniqueInput {
  id: ID
}

type Semester {
  id: ID!
  semester: String!
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
}

type SemesterConnection {
  pageInfo: PageInfo!
  edges: [SemesterEdge]!
  aggregate: AggregateSemester!
}

input SemesterCreateInput {
  id: ID
  semester: String!
  courses: CourseCreateManyWithoutSemestersInput
}

input SemesterCreateManyWithoutCoursesInput {
  create: [SemesterCreateWithoutCoursesInput!]
  connect: [SemesterWhereUniqueInput!]
}

input SemesterCreateOneInput {
  create: SemesterCreateInput
  connect: SemesterWhereUniqueInput
}

input SemesterCreateWithoutCoursesInput {
  id: ID
  semester: String!
}

type SemesterEdge {
  node: Semester!
  cursor: String!
}

enum SemesterOrderByInput {
  id_ASC
  id_DESC
  semester_ASC
  semester_DESC
}

type SemesterPreviousValues {
  id: ID!
  semester: String!
}

input SemesterScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  semester: String
  semester_not: String
  semester_in: [String!]
  semester_not_in: [String!]
  semester_lt: String
  semester_lte: String
  semester_gt: String
  semester_gte: String
  semester_contains: String
  semester_not_contains: String
  semester_starts_with: String
  semester_not_starts_with: String
  semester_ends_with: String
  semester_not_ends_with: String
  AND: [SemesterScalarWhereInput!]
  OR: [SemesterScalarWhereInput!]
  NOT: [SemesterScalarWhereInput!]
}

type SemesterSubscriptionPayload {
  mutation: MutationType!
  node: Semester
  updatedFields: [String!]
  previousValues: SemesterPreviousValues
}

input SemesterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SemesterWhereInput
  AND: [SemesterSubscriptionWhereInput!]
  OR: [SemesterSubscriptionWhereInput!]
  NOT: [SemesterSubscriptionWhereInput!]
}

input SemesterUpdateDataInput {
  semester: String
  courses: CourseUpdateManyWithoutSemestersInput
}

input SemesterUpdateInput {
  semester: String
  courses: CourseUpdateManyWithoutSemestersInput
}

input SemesterUpdateManyDataInput {
  semester: String
}

input SemesterUpdateManyMutationInput {
  semester: String
}

input SemesterUpdateManyWithoutCoursesInput {
  create: [SemesterCreateWithoutCoursesInput!]
  delete: [SemesterWhereUniqueInput!]
  connect: [SemesterWhereUniqueInput!]
  set: [SemesterWhereUniqueInput!]
  disconnect: [SemesterWhereUniqueInput!]
  update: [SemesterUpdateWithWhereUniqueWithoutCoursesInput!]
  upsert: [SemesterUpsertWithWhereUniqueWithoutCoursesInput!]
  deleteMany: [SemesterScalarWhereInput!]
  updateMany: [SemesterUpdateManyWithWhereNestedInput!]
}

input SemesterUpdateManyWithWhereNestedInput {
  where: SemesterScalarWhereInput!
  data: SemesterUpdateManyDataInput!
}

input SemesterUpdateOneRequiredInput {
  create: SemesterCreateInput
  update: SemesterUpdateDataInput
  upsert: SemesterUpsertNestedInput
  connect: SemesterWhereUniqueInput
}

input SemesterUpdateWithoutCoursesDataInput {
  semester: String
}

input SemesterUpdateWithWhereUniqueWithoutCoursesInput {
  where: SemesterWhereUniqueInput!
  data: SemesterUpdateWithoutCoursesDataInput!
}

input SemesterUpsertNestedInput {
  update: SemesterUpdateDataInput!
  create: SemesterCreateInput!
}

input SemesterUpsertWithWhereUniqueWithoutCoursesInput {
  where: SemesterWhereUniqueInput!
  update: SemesterUpdateWithoutCoursesDataInput!
  create: SemesterCreateWithoutCoursesInput!
}

input SemesterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  semester: String
  semester_not: String
  semester_in: [String!]
  semester_not_in: [String!]
  semester_lt: String
  semester_lte: String
  semester_gt: String
  semester_gte: String
  semester_contains: String
  semester_not_contains: String
  semester_starts_with: String
  semester_not_starts_with: String
  semester_ends_with: String
  semester_not_ends_with: String
  courses_every: CourseWhereInput
  courses_some: CourseWhereInput
  courses_none: CourseWhereInput
  AND: [SemesterWhereInput!]
  OR: [SemesterWhereInput!]
  NOT: [SemesterWhereInput!]
}

input SemesterWhereUniqueInput {
  id: ID
  semester: String
}

type Subscription {
  account(where: AccountSubscriptionWhereInput): AccountSubscriptionPayload
  answer(where: AnswerSubscriptionWhereInput): AnswerSubscriptionPayload
  course(where: CourseSubscriptionWhereInput): CourseSubscriptionPayload
  quiz(where: QuizSubscriptionWhereInput): QuizSubscriptionPayload
  quizContents(where: QuizContentsSubscriptionWhereInput): QuizContentsSubscriptionPayload
  semester(where: SemesterSubscriptionWhereInput): SemesterSubscriptionPayload
}
`
      }
    